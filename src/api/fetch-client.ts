/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:1337";
    }

    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    buildingSitesGET(_limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined): Promise<Anonymous> {
        let url_ = this.baseUrl + "/building-sites?";
        if (_limit === null)
            throw new Error("The parameter '_limit' cannot be null.");
        else if (_limit !== undefined)
            url_ += "_limit=" + encodeURIComponent("" + _limit) + "&";
        if (_sort === null)
            throw new Error("The parameter '_sort' cannot be null.");
        else if (_sort !== undefined)
            url_ += "_sort=" + encodeURIComponent("" + _sort) + "&";
        if (_start === null)
            throw new Error("The parameter '_start' cannot be null.");
        else if (_start !== undefined)
            url_ += "_start=" + encodeURIComponent("" + _start) + "&";
        if (eq === null)
            throw new Error("The parameter 'eq' cannot be null.");
        else if (eq !== undefined)
            url_ += "eq=" + encodeURIComponent("" + eq) + "&";
        if (_ne === null)
            throw new Error("The parameter '_ne' cannot be null.");
        else if (_ne !== undefined)
            url_ += "_ne=" + encodeURIComponent("" + _ne) + "&";
        if (_lt === null)
            throw new Error("The parameter '_lt' cannot be null.");
        else if (_lt !== undefined)
            url_ += "_lt=" + encodeURIComponent("" + _lt) + "&";
        if (_lte === null)
            throw new Error("The parameter '_lte' cannot be null.");
        else if (_lte !== undefined)
            url_ += "_lte=" + encodeURIComponent("" + _lte) + "&";
        if (_gt === null)
            throw new Error("The parameter '_gt' cannot be null.");
        else if (_gt !== undefined)
            url_ += "_gt=" + encodeURIComponent("" + _gt) + "&";
        if (_gte === null)
            throw new Error("The parameter '_gte' cannot be null.");
        else if (_gte !== undefined)
            url_ += "_gte=" + encodeURIComponent("" + _gte) + "&";
        if (_contains === null)
            throw new Error("The parameter '_contains' cannot be null.");
        else if (_contains !== undefined)
            url_ += "_contains=" + encodeURIComponent("" + _contains) + "&";
        if (_containss === null)
            throw new Error("The parameter '_containss' cannot be null.");
        else if (_containss !== undefined)
            url_ += "_containss=" + encodeURIComponent("" + _containss) + "&";
        if (_in === null)
            throw new Error("The parameter '_in' cannot be null.");
        else if (_in !== undefined)
            _in && _in.forEach(item => { url_ += "_in=" + encodeURIComponent("" + item) + "&"; });
        if (_nin === null)
            throw new Error("The parameter '_nin' cannot be null.");
        else if (_nin !== undefined)
            _nin && _nin.forEach(item => { url_ += "_nin=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBuildingSitesGET(_response);
        });
    }

    protected processBuildingSitesGET(response: Response): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    buildingSitesPOST(body: NewBuildingSite): Promise<Anonymous2> {
        let url_ = this.baseUrl + "/building-sites";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBuildingSitesPOST(_response);
        });
    }

    protected processBuildingSitesPOST(response: Response): Promise<Anonymous2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    count(): Promise<Anonymous3> {
        let url_ = this.baseUrl + "/building-sites/count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCount(_response);
        });
    }

    protected processCount(response: Response): Promise<Anonymous3> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    buildingSitesGET2(id: string): Promise<Anonymous4> {
        let url_ = this.baseUrl + "/building-sites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBuildingSitesGET2(_response);
        });
    }

    protected processBuildingSitesGET2(response: Response): Promise<Anonymous4> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    buildingSitesPUT(body: NewBuildingSite, id: string): Promise<Anonymous5> {
        let url_ = this.baseUrl + "/building-sites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBuildingSitesPUT(_response);
        });
    }

    protected processBuildingSitesPUT(response: Response): Promise<Anonymous5> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return deletes a single record based on the ID supplied
     */
    buildingSitesDELETE(id: string): Promise<number> {
        let url_ = this.baseUrl + "/building-sites/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBuildingSitesDELETE(_response);
        });
    }

    protected processBuildingSitesDELETE(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    email(body: Body): Promise<Anonymous6> {
        let url_ = this.baseUrl + "/email/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmail(_response);
        });
    }

    protected processEmail(response: Response): Promise<Anonymous6> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    test(body: Body2): Promise<Anonymous7> {
        let url_ = this.baseUrl + "/email/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTest(_response);
        });
    }

    protected processTest(response: Response): Promise<Anonymous7> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    settings(): Promise<Anonymous8> {
        let url_ = this.baseUrl + "/email/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettings(_response);
        });
    }

    protected processSettings(response: Response): Promise<Anonymous8> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    upload(body: Body3): Promise<Anonymous9> {
        let url_ = this.baseUrl + "/upload/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<Anonymous9> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    count2(): Promise<Anonymous10> {
        let url_ = this.baseUrl + "/upload/files/count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCount2(_response);
        });
    }

    protected processCount2(response: Response): Promise<Anonymous10> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    filesGET(): Promise<Anonymous11> {
        let url_ = this.baseUrl + "/upload/files";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilesGET(_response);
        });
    }

    protected processFilesGET(response: Response): Promise<Anonymous11> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    filesGET2(id: string): Promise<Anonymous12> {
        let url_ = this.baseUrl + "/upload/files/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilesGET2(_response);
        });
    }

    protected processFilesGET2(response: Response): Promise<Anonymous12> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    filesDELETE(id: string): Promise<Anonymous13> {
        let url_ = this.baseUrl + "/upload/files/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilesDELETE(_response);
        });
    }

    protected processFilesDELETE(response: Response): Promise<Anonymous13> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    search(id: string): Promise<Anonymous14> {
        let url_ = this.baseUrl + "/upload/search/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<Anonymous14> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    rolesGET(id: string): Promise<UsersPermissionsRole> {
        let url_ = this.baseUrl + "/users-permissions/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesGET(_response);
        });
    }

    protected processRolesGET(response: Response): Promise<UsersPermissionsRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersPermissionsRole.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    rolesAll(_limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined): Promise<UsersPermissionsRole[]> {
        let url_ = this.baseUrl + "/users-permissions/roles?";
        if (_limit === null)
            throw new Error("The parameter '_limit' cannot be null.");
        else if (_limit !== undefined)
            url_ += "_limit=" + encodeURIComponent("" + _limit) + "&";
        if (_sort === null)
            throw new Error("The parameter '_sort' cannot be null.");
        else if (_sort !== undefined)
            url_ += "_sort=" + encodeURIComponent("" + _sort) + "&";
        if (_start === null)
            throw new Error("The parameter '_start' cannot be null.");
        else if (_start !== undefined)
            url_ += "_start=" + encodeURIComponent("" + _start) + "&";
        if (eq === null)
            throw new Error("The parameter 'eq' cannot be null.");
        else if (eq !== undefined)
            url_ += "eq=" + encodeURIComponent("" + eq) + "&";
        if (_ne === null)
            throw new Error("The parameter '_ne' cannot be null.");
        else if (_ne !== undefined)
            url_ += "_ne=" + encodeURIComponent("" + _ne) + "&";
        if (_lt === null)
            throw new Error("The parameter '_lt' cannot be null.");
        else if (_lt !== undefined)
            url_ += "_lt=" + encodeURIComponent("" + _lt) + "&";
        if (_lte === null)
            throw new Error("The parameter '_lte' cannot be null.");
        else if (_lte !== undefined)
            url_ += "_lte=" + encodeURIComponent("" + _lte) + "&";
        if (_gt === null)
            throw new Error("The parameter '_gt' cannot be null.");
        else if (_gt !== undefined)
            url_ += "_gt=" + encodeURIComponent("" + _gt) + "&";
        if (_gte === null)
            throw new Error("The parameter '_gte' cannot be null.");
        else if (_gte !== undefined)
            url_ += "_gte=" + encodeURIComponent("" + _gte) + "&";
        if (_contains === null)
            throw new Error("The parameter '_contains' cannot be null.");
        else if (_contains !== undefined)
            url_ += "_contains=" + encodeURIComponent("" + _contains) + "&";
        if (_containss === null)
            throw new Error("The parameter '_containss' cannot be null.");
        else if (_containss !== undefined)
            url_ += "_containss=" + encodeURIComponent("" + _containss) + "&";
        if (_in === null)
            throw new Error("The parameter '_in' cannot be null.");
        else if (_in !== undefined)
            _in && _in.forEach(item => { url_ += "_in=" + encodeURIComponent("" + item) + "&"; });
        if (_nin === null)
            throw new Error("The parameter '_nin' cannot be null.");
        else if (_nin !== undefined)
            _nin && _nin.forEach(item => { url_ += "_nin=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesAll(_response);
        });
    }

    protected processRolesAll(response: Response): Promise<UsersPermissionsRole[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UsersPermissionsRole.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    rolesPOST(body: NewUsersPermissionsRole): Promise<UsersPermissionsRole> {
        let url_ = this.baseUrl + "/users-permissions/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesPOST(_response);
        });
    }

    protected processRolesPOST(response: Response): Promise<UsersPermissionsRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersPermissionsRole.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    rolesPUT(role: string, body: NewUsersPermissionsRole): Promise<UsersPermissionsRole> {
        let url_ = this.baseUrl + "/users-permissions/roles/{role}";
        if (role === undefined || role === null)
            throw new Error("The parameter 'role' must be defined.");
        url_ = url_.replace("{role}", encodeURIComponent("" + role));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesPUT(_response);
        });
    }

    protected processRolesPUT(response: Response): Promise<UsersPermissionsRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersPermissionsRole.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    rolesDELETE(role: string): Promise<Anonymous15> {
        let url_ = this.baseUrl + "/users-permissions/roles/{role}";
        if (role === undefined || role === null)
            throw new Error("The parameter 'role' must be defined.");
        url_ = url_.replace("{role}", encodeURIComponent("" + role));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRolesDELETE(_response);
        });
    }

    protected processRolesDELETE(response: Response): Promise<Anonymous15> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    searchAll(id: string, _limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined): Promise<UsersPermissionsUser[]> {
        let url_ = this.baseUrl + "/users-permissions/search/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (_limit === null)
            throw new Error("The parameter '_limit' cannot be null.");
        else if (_limit !== undefined)
            url_ += "_limit=" + encodeURIComponent("" + _limit) + "&";
        if (_sort === null)
            throw new Error("The parameter '_sort' cannot be null.");
        else if (_sort !== undefined)
            url_ += "_sort=" + encodeURIComponent("" + _sort) + "&";
        if (_start === null)
            throw new Error("The parameter '_start' cannot be null.");
        else if (_start !== undefined)
            url_ += "_start=" + encodeURIComponent("" + _start) + "&";
        if (eq === null)
            throw new Error("The parameter 'eq' cannot be null.");
        else if (eq !== undefined)
            url_ += "eq=" + encodeURIComponent("" + eq) + "&";
        if (_ne === null)
            throw new Error("The parameter '_ne' cannot be null.");
        else if (_ne !== undefined)
            url_ += "_ne=" + encodeURIComponent("" + _ne) + "&";
        if (_lt === null)
            throw new Error("The parameter '_lt' cannot be null.");
        else if (_lt !== undefined)
            url_ += "_lt=" + encodeURIComponent("" + _lt) + "&";
        if (_lte === null)
            throw new Error("The parameter '_lte' cannot be null.");
        else if (_lte !== undefined)
            url_ += "_lte=" + encodeURIComponent("" + _lte) + "&";
        if (_gt === null)
            throw new Error("The parameter '_gt' cannot be null.");
        else if (_gt !== undefined)
            url_ += "_gt=" + encodeURIComponent("" + _gt) + "&";
        if (_gte === null)
            throw new Error("The parameter '_gte' cannot be null.");
        else if (_gte !== undefined)
            url_ += "_gte=" + encodeURIComponent("" + _gte) + "&";
        if (_contains === null)
            throw new Error("The parameter '_contains' cannot be null.");
        else if (_contains !== undefined)
            url_ += "_contains=" + encodeURIComponent("" + _contains) + "&";
        if (_containss === null)
            throw new Error("The parameter '_containss' cannot be null.");
        else if (_containss !== undefined)
            url_ += "_containss=" + encodeURIComponent("" + _containss) + "&";
        if (_in === null)
            throw new Error("The parameter '_in' cannot be null.");
        else if (_in !== undefined)
            _in && _in.forEach(item => { url_ += "_in=" + encodeURIComponent("" + item) + "&"; });
        if (_nin === null)
            throw new Error("The parameter '_nin' cannot be null.");
        else if (_nin !== undefined)
            _nin && _nin.forEach(item => { url_ += "_nin=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchAll(_response);
        });
    }

    protected processSearchAll(response: Response): Promise<UsersPermissionsUser[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UsersPermissionsUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    *(): Promise<Anonymous16> {
        let url_ = this.baseUrl + "/connect/*";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process*(_response);
        });
    }

    protected process*(response: Response): Promise<Anonymous16> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    local(body: Body4): Promise<Anonymous17> {
        let url_ = this.baseUrl + "/auth/local";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLocal(_response);
        });
    }

    protected processLocal(response: Response): Promise<Anonymous17> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    register(body: NewUsersPermissionsUser): Promise<UsersPermissionsUser> {
        let url_ = this.baseUrl + "/auth/local/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<UsersPermissionsUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersPermissionsUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    callback(provider: string): Promise<Anonymous18> {
        let url_ = this.baseUrl + "/auth/{provider}/callback";
        if (provider === undefined || provider === null)
            throw new Error("The parameter 'provider' must be defined.");
        url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCallback(_response);
        });
    }

    protected processCallback(response: Response): Promise<Anonymous18> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    forgotPassword(body: Body5): Promise<Anonymous19> {
        let url_ = this.baseUrl + "/auth/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<Anonymous19> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    resetPassword(body: Body6): Promise<Anonymous20> {
        let url_ = this.baseUrl + "/auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<Anonymous20> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    emailConfirmation(): Promise<Anonymous21> {
        let url_ = this.baseUrl + "/auth/email-confirmation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmailConfirmation(_response);
        });
    }

    protected processEmailConfirmation(response: Response): Promise<Anonymous21> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    sendEmailConfirmation(body: Body7): Promise<Anonymous22> {
        let url_ = this.baseUrl + "/auth/send-email-confirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendEmailConfirmation(_response);
        });
    }

    protected processSendEmailConfirmation(response: Response): Promise<Anonymous22> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    usersAll(_limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined): Promise<UsersPermissionsUser[]> {
        let url_ = this.baseUrl + "/users?";
        if (_limit === null)
            throw new Error("The parameter '_limit' cannot be null.");
        else if (_limit !== undefined)
            url_ += "_limit=" + encodeURIComponent("" + _limit) + "&";
        if (_sort === null)
            throw new Error("The parameter '_sort' cannot be null.");
        else if (_sort !== undefined)
            url_ += "_sort=" + encodeURIComponent("" + _sort) + "&";
        if (_start === null)
            throw new Error("The parameter '_start' cannot be null.");
        else if (_start !== undefined)
            url_ += "_start=" + encodeURIComponent("" + _start) + "&";
        if (eq === null)
            throw new Error("The parameter 'eq' cannot be null.");
        else if (eq !== undefined)
            url_ += "eq=" + encodeURIComponent("" + eq) + "&";
        if (_ne === null)
            throw new Error("The parameter '_ne' cannot be null.");
        else if (_ne !== undefined)
            url_ += "_ne=" + encodeURIComponent("" + _ne) + "&";
        if (_lt === null)
            throw new Error("The parameter '_lt' cannot be null.");
        else if (_lt !== undefined)
            url_ += "_lt=" + encodeURIComponent("" + _lt) + "&";
        if (_lte === null)
            throw new Error("The parameter '_lte' cannot be null.");
        else if (_lte !== undefined)
            url_ += "_lte=" + encodeURIComponent("" + _lte) + "&";
        if (_gt === null)
            throw new Error("The parameter '_gt' cannot be null.");
        else if (_gt !== undefined)
            url_ += "_gt=" + encodeURIComponent("" + _gt) + "&";
        if (_gte === null)
            throw new Error("The parameter '_gte' cannot be null.");
        else if (_gte !== undefined)
            url_ += "_gte=" + encodeURIComponent("" + _gte) + "&";
        if (_contains === null)
            throw new Error("The parameter '_contains' cannot be null.");
        else if (_contains !== undefined)
            url_ += "_contains=" + encodeURIComponent("" + _contains) + "&";
        if (_containss === null)
            throw new Error("The parameter '_containss' cannot be null.");
        else if (_containss !== undefined)
            url_ += "_containss=" + encodeURIComponent("" + _containss) + "&";
        if (_in === null)
            throw new Error("The parameter '_in' cannot be null.");
        else if (_in !== undefined)
            _in && _in.forEach(item => { url_ += "_in=" + encodeURIComponent("" + item) + "&"; });
        if (_nin === null)
            throw new Error("The parameter '_nin' cannot be null.");
        else if (_nin !== undefined)
            _nin && _nin.forEach(item => { url_ += "_nin=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersAll(_response);
        });
    }

    protected processUsersAll(response: Response): Promise<UsersPermissionsUser[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UsersPermissionsUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    me(): Promise<UsersPermissionsUser> {
        let url_ = this.baseUrl + "/users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMe(_response);
        });
    }

    protected processMe(response: Response): Promise<UsersPermissionsUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersPermissionsUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    usersGET(id: string): Promise<UsersPermissionsUser> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersGET(_response);
        });
    }

    protected processUsersGET(response: Response): Promise<UsersPermissionsUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersPermissionsUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    usersPUT(id: string, body: NewUsersPermissionsUser): Promise<UsersPermissionsUser> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersPUT(_response);
        });
    }

    protected processUsersPUT(response: Response): Promise<UsersPermissionsUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersPermissionsUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return response
     */
    usersDELETE(id: string): Promise<Anonymous23> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersDELETE(_response);
        });
    }

    protected processUsersDELETE(response: Response): Promise<Anonymous23> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ErrorDto.fromJS(resultDatadefault);
            return throwException("unexpected error", status, _responseText, _headers, resultdefault);
            });
        }
    }
}
type BuildingSitesGETQueryParameters = {
      _limit: number | undefined;
      _sort: string | undefined;
      _start: number | undefined;
      eq: string | undefined;
      _ne: string | undefined;
      _lt: string | undefined;
      _lte: string | undefined;
      _gt: string | undefined;
      _gte: string | undefined;
      _contains: string | undefined;
      _containss: string | undefined;
      _in: string[] | undefined;
      _nin: string[] | undefined;
};

type BuildingSitesGET2QueryParameters = {
      id: string;
};

type FilesGET2QueryParameters = {
      id: string;
};

type SearchQueryParameters = {
      id: string;
};

type RolesGETQueryParameters = {
      id: string;
};

type RolesAllQueryParameters = {
      _limit: number | undefined;
      _sort: string | undefined;
      _start: number | undefined;
      eq: string | undefined;
      _ne: string | undefined;
      _lt: string | undefined;
      _lte: string | undefined;
      _gt: string | undefined;
      _gte: string | undefined;
      _contains: string | undefined;
      _containss: string | undefined;
      _in: string[] | undefined;
      _nin: string[] | undefined;
};

type SearchAllQueryParameters = {
      id: string;
      _limit: number | undefined;
      _sort: string | undefined;
      _start: number | undefined;
      eq: string | undefined;
      _ne: string | undefined;
      _lt: string | undefined;
      _lte: string | undefined;
      _gt: string | undefined;
      _gte: string | undefined;
      _contains: string | undefined;
      _containss: string | undefined;
      _in: string[] | undefined;
      _nin: string[] | undefined;
};

type CallbackQueryParameters = {
      provider: string;
};

type UsersAllQueryParameters = {
      _limit: number | undefined;
      _sort: string | undefined;
      _start: number | undefined;
      eq: string | undefined;
      _ne: string | undefined;
      _lt: string | undefined;
      _lte: string | undefined;
      _gt: string | undefined;
      _gte: string | undefined;
      _contains: string | undefined;
      _containss: string | undefined;
      _in: string[] | undefined;
      _nin: string[] | undefined;
};

type UsersGETQueryParameters = {
      id: string;
};

export class Query{

    get baseUrl() {
      return getBaseUrl() ?? '' + 'http://localhost:1337';
    }

    static get Client() {
        return createClient(Client);
    }

    static get Url() {
        return new Query();
    }

    buildingSitesGET(_limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined): string {
      let url_ = this.baseUrl + "/building-sites?";
    if (_limit === null)
        throw new Error("The parameter '_limit' cannot be null.");
    else if (_limit !== undefined)
        url_ += "_limit=" + encodeURIComponent("" + _limit) + "&";
    if (_sort === null)
        throw new Error("The parameter '_sort' cannot be null.");
    else if (_sort !== undefined)
        url_ += "_sort=" + encodeURIComponent("" + _sort) + "&";
    if (_start === null)
        throw new Error("The parameter '_start' cannot be null.");
    else if (_start !== undefined)
        url_ += "_start=" + encodeURIComponent("" + _start) + "&";
    if (eq === null)
        throw new Error("The parameter 'eq' cannot be null.");
    else if (eq !== undefined)
        url_ += "eq=" + encodeURIComponent("" + eq) + "&";
    if (_ne === null)
        throw new Error("The parameter '_ne' cannot be null.");
    else if (_ne !== undefined)
        url_ += "_ne=" + encodeURIComponent("" + _ne) + "&";
    if (_lt === null)
        throw new Error("The parameter '_lt' cannot be null.");
    else if (_lt !== undefined)
        url_ += "_lt=" + encodeURIComponent("" + _lt) + "&";
    if (_lte === null)
        throw new Error("The parameter '_lte' cannot be null.");
    else if (_lte !== undefined)
        url_ += "_lte=" + encodeURIComponent("" + _lte) + "&";
    if (_gt === null)
        throw new Error("The parameter '_gt' cannot be null.");
    else if (_gt !== undefined)
        url_ += "_gt=" + encodeURIComponent("" + _gt) + "&";
    if (_gte === null)
        throw new Error("The parameter '_gte' cannot be null.");
    else if (_gte !== undefined)
        url_ += "_gte=" + encodeURIComponent("" + _gte) + "&";
    if (_contains === null)
        throw new Error("The parameter '_contains' cannot be null.");
    else if (_contains !== undefined)
        url_ += "_contains=" + encodeURIComponent("" + _contains) + "&";
    if (_containss === null)
        throw new Error("The parameter '_containss' cannot be null.");
    else if (_containss !== undefined)
        url_ += "_containss=" + encodeURIComponent("" + _containss) + "&";
    if (_in === null)
        throw new Error("The parameter '_in' cannot be null.");
    else if (_in !== undefined)
        _in && _in.forEach(item => { url_ += "_in=" + encodeURIComponent("" + item) + "&"; });
    if (_nin === null)
        throw new Error("The parameter '_nin' cannot be null.");
    else if (_nin !== undefined)
        _nin && _nin.forEach(item => { url_ += "_nin=" + encodeURIComponent("" + item) + "&"; });
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static buildingSitesGETDefaultOptions?: UseQueryOptions<Anonymous, unknown, Anonymous> = {};
    public static buildingSitesGETQueryKey(dto: BuildingSitesGETQueryParameters): QueryKey;
    public static buildingSitesGETQueryKey(_limit: number | undefined,_sort: string | undefined,_start: number | undefined,eq: string | undefined,_ne: string | undefined,_lt: string | undefined,_lte: string | undefined,_gt: string | undefined,_gte: string | undefined,_contains: string | undefined,_containss: string | undefined,_in: string[] | undefined,_nin: string[] | undefined): QueryKey;
    public static buildingSitesGETQueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  } = params[0] as BuildingSitesGETQueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'buildingSitesGET',
                _limit as any,
                _sort as any,
                _start as any,
                eq as any,
                _ne as any,
                _lt as any,
                _lte as any,
                _gt as any,
                _gte as any,
                _contains as any,
                _containss as any,
                _in as any,
                _nin as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'buildingSitesGET',
                ...params
            ]);
        }
        
    }

    private static buildingSitesGET(context: QueryFunctionContext) {
        return Query.Client.buildingSitesGET(
                context.queryKey[2] as number | undefined, 
                context.queryKey[3] as string | undefined, 
                context.queryKey[4] as number | undefined, 
                context.queryKey[5] as string | undefined, 
                context.queryKey[6] as string | undefined, 
                context.queryKey[7] as string | undefined, 
                context.queryKey[8] as string | undefined, 
                context.queryKey[9] as string | undefined, 
                context.queryKey[10] as string | undefined, 
                context.queryKey[11] as string | undefined, 
                context.queryKey[12] as string | undefined, 
                context.queryKey[13] as string[] | undefined, 
                context.queryKey[14] as string[] | undefined
            );
    }

    static useBuildingSitesGETQuery<TSelectData = Anonymous, TError = unknown>(dto: BuildingSitesGETQueryParameters, options?: UseQueryOptions<Anonymous, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static useBuildingSitesGETQuery<TSelectData = Anonymous, TError = unknown>(_limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined, options?: UseQueryOptions<Anonymous, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useBuildingSitesGETQuery<TSelectData = Anonymous, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous, TError, TSelectData> | undefined = undefined;
        let _limit: any = undefined;
        let _sort: any = undefined;
        let _start: any = undefined;
        let eq: any = undefined;
        let _ne: any = undefined;
        let _lt: any = undefined;
        let _lte: any = undefined;
        let _gt: any = undefined;
        let _gte: any = undefined;
        let _contains: any = undefined;
        let _containss: any = undefined;
        let _in: any = undefined;
        let _nin: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  } = params[0] as BuildingSitesGETQueryParameters);
                options = params[1];
            } else {
                [_limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  options] = params;
            }
        }
    

        return useQuery<Anonymous, TError, TSelectData>({
            queryFn: Query.buildingSitesGET,
            queryKey: Query.buildingSitesGETQueryKey(_limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin),
            ...Query.buildingSitesGETDefaultOptions as unknown as UseQueryOptions<Anonymous, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static setBuildingSitesGETData(queryClient: QueryClient, updater: (data: Anonymous | undefined) => Anonymous, _limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined) {
        queryClient.setQueryData(Query.buildingSitesGETQueryKey(_limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin),
            updater
        );
    }

    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static setBuildingSitesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous | undefined) => Anonymous) {
        queryClient.setQueryData(queryKey, updater);
    }
      

    count(): string {
      let url_ = this.baseUrl + "/building-sites/count";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static countDefaultOptions?: UseQueryOptions<Anonymous3, unknown, Anonymous3> = {};
    public static countQueryKey(): QueryKey;
    public static countQueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'Client',
            'count',
            ]);
        
    }

    private static count() {
        return Query.Client.count(
            );
    }

    /**
     * @return response
     */
    static useCountQuery<TSelectData = Anonymous3, TError = unknown>(options?: UseQueryOptions<Anonymous3, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useCountQuery<TSelectData = Anonymous3, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous3, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        return useQuery<Anonymous3, TError, TSelectData>({
            queryFn: Query.count,
            queryKey: Query.countQueryKey(),
            ...Query.countDefaultOptions as unknown as UseQueryOptions<Anonymous3, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setCountData(queryClient: QueryClient, updater: (data: Anonymous3 | undefined) => Anonymous3, ) {
        queryClient.setQueryData(Query.countQueryKey(),
            updater
        );
    }

    /**
     * @return response
     */
    static setCountDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous3 | undefined) => Anonymous3) {
        queryClient.setQueryData(queryKey, updater);
    }
    

    buildingSitesGET2(id: string): string {
      let url_ = this.baseUrl + "/building-sites/{id}";
    if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static buildingSitesGET2DefaultOptions?: UseQueryOptions<Anonymous4, unknown, Anonymous4> = {};
    public static buildingSitesGET2QueryKey(id: string): QueryKey;
    public static buildingSitesGET2QueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { id,  } = params[0] as BuildingSitesGET2QueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'buildingSitesGET2',
                id as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'buildingSitesGET2',
                ...params
            ]);
        }
        
    }

    private static buildingSitesGET2(context: QueryFunctionContext) {
        return Query.Client.buildingSitesGET2(
                context.queryKey[2] as string
            );
    }

    static useBuildingSitesGET2Query<TSelectData = Anonymous4, TError = unknown>(dto: BuildingSitesGET2QueryParameters, options?: UseQueryOptions<Anonymous4, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @return response
     */
    static useBuildingSitesGET2Query<TSelectData = Anonymous4, TError = unknown>(id: string, options?: UseQueryOptions<Anonymous4, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useBuildingSitesGET2Query<TSelectData = Anonymous4, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous4, TError, TSelectData> | undefined = undefined;
        let id: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ id,  } = params[0] as BuildingSitesGET2QueryParameters);
                options = params[1];
            } else {
                [id,  options] = params;
            }
        }
    

        return useQuery<Anonymous4, TError, TSelectData>({
            queryFn: Query.buildingSitesGET2,
            queryKey: Query.buildingSitesGET2QueryKey(id),
            ...Query.buildingSitesGET2DefaultOptions as unknown as UseQueryOptions<Anonymous4, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setBuildingSitesGET2Data(queryClient: QueryClient, updater: (data: Anonymous4 | undefined) => Anonymous4, id: string) {
        queryClient.setQueryData(Query.buildingSitesGET2QueryKey(id),
            updater
        );
    }

    /**
     * @return response
     */
    static setBuildingSitesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous4 | undefined) => Anonymous4) {
        queryClient.setQueryData(queryKey, updater);
    }
            

    settings(): string {
      let url_ = this.baseUrl + "/email/settings";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static settingsDefaultOptions?: UseQueryOptions<Anonymous8, unknown, Anonymous8> = {};
    public static settingsQueryKey(): QueryKey;
    public static settingsQueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'Client',
            'settings',
            ]);
        
    }

    private static settings() {
        return Query.Client.settings(
            );
    }

    /**
     * @return response
     */
    static useSettingsQuery<TSelectData = Anonymous8, TError = unknown>(options?: UseQueryOptions<Anonymous8, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useSettingsQuery<TSelectData = Anonymous8, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous8, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        return useQuery<Anonymous8, TError, TSelectData>({
            queryFn: Query.settings,
            queryKey: Query.settingsQueryKey(),
            ...Query.settingsDefaultOptions as unknown as UseQueryOptions<Anonymous8, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setSettingsData(queryClient: QueryClient, updater: (data: Anonymous8 | undefined) => Anonymous8, ) {
        queryClient.setQueryData(Query.settingsQueryKey(),
            updater
        );
    }

    /**
     * @return response
     */
    static setSettingsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous8 | undefined) => Anonymous8) {
        queryClient.setQueryData(queryKey, updater);
    }
      

    count2(): string {
      let url_ = this.baseUrl + "/upload/files/count";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static count2DefaultOptions?: UseQueryOptions<Anonymous10, unknown, Anonymous10> = {};
    public static count2QueryKey(): QueryKey;
    public static count2QueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'Client',
            'count2',
            ]);
        
    }

    private static count2() {
        return Query.Client.count2(
            );
    }

    /**
     * @return response
     */
    static useCount2Query<TSelectData = Anonymous10, TError = unknown>(options?: UseQueryOptions<Anonymous10, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useCount2Query<TSelectData = Anonymous10, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous10, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        return useQuery<Anonymous10, TError, TSelectData>({
            queryFn: Query.count2,
            queryKey: Query.count2QueryKey(),
            ...Query.count2DefaultOptions as unknown as UseQueryOptions<Anonymous10, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setCount2Data(queryClient: QueryClient, updater: (data: Anonymous10 | undefined) => Anonymous10, ) {
        queryClient.setQueryData(Query.count2QueryKey(),
            updater
        );
    }

    /**
     * @return response
     */
    static setCount2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous10 | undefined) => Anonymous10) {
        queryClient.setQueryData(queryKey, updater);
    }
    

    filesGET(): string {
      let url_ = this.baseUrl + "/upload/files";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static filesGETDefaultOptions?: UseQueryOptions<Anonymous11, unknown, Anonymous11> = {};
    public static filesGETQueryKey(): QueryKey;
    public static filesGETQueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'Client',
            'filesGET',
            ]);
        
    }

    private static filesGET() {
        return Query.Client.filesGET(
            );
    }

    /**
     * @return response
     */
    static useFilesGETQuery<TSelectData = Anonymous11, TError = unknown>(options?: UseQueryOptions<Anonymous11, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useFilesGETQuery<TSelectData = Anonymous11, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous11, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        return useQuery<Anonymous11, TError, TSelectData>({
            queryFn: Query.filesGET,
            queryKey: Query.filesGETQueryKey(),
            ...Query.filesGETDefaultOptions as unknown as UseQueryOptions<Anonymous11, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setFilesGETData(queryClient: QueryClient, updater: (data: Anonymous11 | undefined) => Anonymous11, ) {
        queryClient.setQueryData(Query.filesGETQueryKey(),
            updater
        );
    }

    /**
     * @return response
     */
    static setFilesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous11 | undefined) => Anonymous11) {
        queryClient.setQueryData(queryKey, updater);
    }
    

    filesGET2(id: string): string {
      let url_ = this.baseUrl + "/upload/files/{id}";
    if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static filesGET2DefaultOptions?: UseQueryOptions<Anonymous12, unknown, Anonymous12> = {};
    public static filesGET2QueryKey(id: string): QueryKey;
    public static filesGET2QueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { id,  } = params[0] as FilesGET2QueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'filesGET2',
                id as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'filesGET2',
                ...params
            ]);
        }
        
    }

    private static filesGET2(context: QueryFunctionContext) {
        return Query.Client.filesGET2(
                context.queryKey[2] as string
            );
    }

    static useFilesGET2Query<TSelectData = Anonymous12, TError = unknown>(dto: FilesGET2QueryParameters, options?: UseQueryOptions<Anonymous12, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @return response
     */
    static useFilesGET2Query<TSelectData = Anonymous12, TError = unknown>(id: string, options?: UseQueryOptions<Anonymous12, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useFilesGET2Query<TSelectData = Anonymous12, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous12, TError, TSelectData> | undefined = undefined;
        let id: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ id,  } = params[0] as FilesGET2QueryParameters);
                options = params[1];
            } else {
                [id,  options] = params;
            }
        }
    

        return useQuery<Anonymous12, TError, TSelectData>({
            queryFn: Query.filesGET2,
            queryKey: Query.filesGET2QueryKey(id),
            ...Query.filesGET2DefaultOptions as unknown as UseQueryOptions<Anonymous12, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setFilesGET2Data(queryClient: QueryClient, updater: (data: Anonymous12 | undefined) => Anonymous12, id: string) {
        queryClient.setQueryData(Query.filesGET2QueryKey(id),
            updater
        );
    }

    /**
     * @return response
     */
    static setFilesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous12 | undefined) => Anonymous12) {
        queryClient.setQueryData(queryKey, updater);
    }
      

    search(id: string): string {
      let url_ = this.baseUrl + "/upload/search/{id}";
    if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static searchDefaultOptions?: UseQueryOptions<Anonymous14, unknown, Anonymous14> = {};
    public static searchQueryKey(id: string): QueryKey;
    public static searchQueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { id,  } = params[0] as SearchQueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'search',
                id as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'search',
                ...params
            ]);
        }
        
    }

    private static search(context: QueryFunctionContext) {
        return Query.Client.search(
                context.queryKey[2] as string
            );
    }

    static useSearchQuery<TSelectData = Anonymous14, TError = unknown>(dto: SearchQueryParameters, options?: UseQueryOptions<Anonymous14, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @return response
     */
    static useSearchQuery<TSelectData = Anonymous14, TError = unknown>(id: string, options?: UseQueryOptions<Anonymous14, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useSearchQuery<TSelectData = Anonymous14, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous14, TError, TSelectData> | undefined = undefined;
        let id: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ id,  } = params[0] as SearchQueryParameters);
                options = params[1];
            } else {
                [id,  options] = params;
            }
        }
    

        return useQuery<Anonymous14, TError, TSelectData>({
            queryFn: Query.search,
            queryKey: Query.searchQueryKey(id),
            ...Query.searchDefaultOptions as unknown as UseQueryOptions<Anonymous14, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setSearchData(queryClient: QueryClient, updater: (data: Anonymous14 | undefined) => Anonymous14, id: string) {
        queryClient.setQueryData(Query.searchQueryKey(id),
            updater
        );
    }

    /**
     * @return response
     */
    static setSearchDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous14 | undefined) => Anonymous14) {
        queryClient.setQueryData(queryKey, updater);
    }
    

    rolesGET(id: string): string {
      let url_ = this.baseUrl + "/users-permissions/roles/{id}";
    if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static rolesGETDefaultOptions?: UseQueryOptions<UsersPermissionsRole, unknown, UsersPermissionsRole> = {};
    public static rolesGETQueryKey(id: string): QueryKey;
    public static rolesGETQueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { id,  } = params[0] as RolesGETQueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'rolesGET',
                id as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'rolesGET',
                ...params
            ]);
        }
        
    }

    private static rolesGET(context: QueryFunctionContext) {
        return Query.Client.rolesGET(
                context.queryKey[2] as string
            );
    }

    static useRolesGETQuery<TSelectData = UsersPermissionsRole, TError = unknown>(dto: RolesGETQueryParameters, options?: UseQueryOptions<UsersPermissionsRole, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @return response
     */
    static useRolesGETQuery<TSelectData = UsersPermissionsRole, TError = unknown>(id: string, options?: UseQueryOptions<UsersPermissionsRole, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useRolesGETQuery<TSelectData = UsersPermissionsRole, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<UsersPermissionsRole, TError, TSelectData> | undefined = undefined;
        let id: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ id,  } = params[0] as RolesGETQueryParameters);
                options = params[1];
            } else {
                [id,  options] = params;
            }
        }
    

        return useQuery<UsersPermissionsRole, TError, TSelectData>({
            queryFn: Query.rolesGET,
            queryKey: Query.rolesGETQueryKey(id),
            ...Query.rolesGETDefaultOptions as unknown as UseQueryOptions<UsersPermissionsRole, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setRolesGETData(queryClient: QueryClient, updater: (data: UsersPermissionsRole | undefined) => UsersPermissionsRole, id: string) {
        queryClient.setQueryData(Query.rolesGETQueryKey(id),
            updater
        );
    }

    /**
     * @return response
     */
    static setRolesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: UsersPermissionsRole | undefined) => UsersPermissionsRole) {
        queryClient.setQueryData(queryKey, updater);
    }
    

    rolesAll(_limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined): string {
      let url_ = this.baseUrl + "/users-permissions/roles?";
    if (_limit === null)
        throw new Error("The parameter '_limit' cannot be null.");
    else if (_limit !== undefined)
        url_ += "_limit=" + encodeURIComponent("" + _limit) + "&";
    if (_sort === null)
        throw new Error("The parameter '_sort' cannot be null.");
    else if (_sort !== undefined)
        url_ += "_sort=" + encodeURIComponent("" + _sort) + "&";
    if (_start === null)
        throw new Error("The parameter '_start' cannot be null.");
    else if (_start !== undefined)
        url_ += "_start=" + encodeURIComponent("" + _start) + "&";
    if (eq === null)
        throw new Error("The parameter 'eq' cannot be null.");
    else if (eq !== undefined)
        url_ += "eq=" + encodeURIComponent("" + eq) + "&";
    if (_ne === null)
        throw new Error("The parameter '_ne' cannot be null.");
    else if (_ne !== undefined)
        url_ += "_ne=" + encodeURIComponent("" + _ne) + "&";
    if (_lt === null)
        throw new Error("The parameter '_lt' cannot be null.");
    else if (_lt !== undefined)
        url_ += "_lt=" + encodeURIComponent("" + _lt) + "&";
    if (_lte === null)
        throw new Error("The parameter '_lte' cannot be null.");
    else if (_lte !== undefined)
        url_ += "_lte=" + encodeURIComponent("" + _lte) + "&";
    if (_gt === null)
        throw new Error("The parameter '_gt' cannot be null.");
    else if (_gt !== undefined)
        url_ += "_gt=" + encodeURIComponent("" + _gt) + "&";
    if (_gte === null)
        throw new Error("The parameter '_gte' cannot be null.");
    else if (_gte !== undefined)
        url_ += "_gte=" + encodeURIComponent("" + _gte) + "&";
    if (_contains === null)
        throw new Error("The parameter '_contains' cannot be null.");
    else if (_contains !== undefined)
        url_ += "_contains=" + encodeURIComponent("" + _contains) + "&";
    if (_containss === null)
        throw new Error("The parameter '_containss' cannot be null.");
    else if (_containss !== undefined)
        url_ += "_containss=" + encodeURIComponent("" + _containss) + "&";
    if (_in === null)
        throw new Error("The parameter '_in' cannot be null.");
    else if (_in !== undefined)
        _in && _in.forEach(item => { url_ += "_in=" + encodeURIComponent("" + item) + "&"; });
    if (_nin === null)
        throw new Error("The parameter '_nin' cannot be null.");
    else if (_nin !== undefined)
        _nin && _nin.forEach(item => { url_ += "_nin=" + encodeURIComponent("" + item) + "&"; });
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static rolesAllDefaultOptions?: UseQueryOptions<UsersPermissionsRole[], unknown, UsersPermissionsRole[]> = {};
    public static rolesAllQueryKey(dto: RolesAllQueryParameters): QueryKey;
    public static rolesAllQueryKey(_limit: number | undefined,_sort: string | undefined,_start: number | undefined,eq: string | undefined,_ne: string | undefined,_lt: string | undefined,_lte: string | undefined,_gt: string | undefined,_gte: string | undefined,_contains: string | undefined,_containss: string | undefined,_in: string[] | undefined,_nin: string[] | undefined): QueryKey;
    public static rolesAllQueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  } = params[0] as RolesAllQueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'rolesAll',
                _limit as any,
                _sort as any,
                _start as any,
                eq as any,
                _ne as any,
                _lt as any,
                _lte as any,
                _gt as any,
                _gte as any,
                _contains as any,
                _containss as any,
                _in as any,
                _nin as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'rolesAll',
                ...params
            ]);
        }
        
    }

    private static rolesAll(context: QueryFunctionContext) {
        return Query.Client.rolesAll(
                context.queryKey[2] as number | undefined, 
                context.queryKey[3] as string | undefined, 
                context.queryKey[4] as number | undefined, 
                context.queryKey[5] as string | undefined, 
                context.queryKey[6] as string | undefined, 
                context.queryKey[7] as string | undefined, 
                context.queryKey[8] as string | undefined, 
                context.queryKey[9] as string | undefined, 
                context.queryKey[10] as string | undefined, 
                context.queryKey[11] as string | undefined, 
                context.queryKey[12] as string | undefined, 
                context.queryKey[13] as string[] | undefined, 
                context.queryKey[14] as string[] | undefined
            );
    }

    static useRolesAllQuery<TSelectData = UsersPermissionsRole[], TError = unknown>(dto: RolesAllQueryParameters, options?: UseQueryOptions<UsersPermissionsRole[], TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static useRolesAllQuery<TSelectData = UsersPermissionsRole[], TError = unknown>(_limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined, options?: UseQueryOptions<UsersPermissionsRole[], TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useRolesAllQuery<TSelectData = UsersPermissionsRole[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<UsersPermissionsRole[], TError, TSelectData> | undefined = undefined;
        let _limit: any = undefined;
        let _sort: any = undefined;
        let _start: any = undefined;
        let eq: any = undefined;
        let _ne: any = undefined;
        let _lt: any = undefined;
        let _lte: any = undefined;
        let _gt: any = undefined;
        let _gte: any = undefined;
        let _contains: any = undefined;
        let _containss: any = undefined;
        let _in: any = undefined;
        let _nin: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  } = params[0] as RolesAllQueryParameters);
                options = params[1];
            } else {
                [_limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  options] = params;
            }
        }
    

        return useQuery<UsersPermissionsRole[], TError, TSelectData>({
            queryFn: Query.rolesAll,
            queryKey: Query.rolesAllQueryKey(_limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin),
            ...Query.rolesAllDefaultOptions as unknown as UseQueryOptions<UsersPermissionsRole[], TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static setRolesAllData(queryClient: QueryClient, updater: (data: UsersPermissionsRole[] | undefined) => UsersPermissionsRole[], _limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined) {
        queryClient.setQueryData(Query.rolesAllQueryKey(_limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin),
            updater
        );
    }

    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static setRolesAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: UsersPermissionsRole[] | undefined) => UsersPermissionsRole[]) {
        queryClient.setQueryData(queryKey, updater);
    }
          

    searchAll(id: string, _limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined): string {
      let url_ = this.baseUrl + "/users-permissions/search/{id}?";
    if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (_limit === null)
        throw new Error("The parameter '_limit' cannot be null.");
    else if (_limit !== undefined)
        url_ += "_limit=" + encodeURIComponent("" + _limit) + "&";
    if (_sort === null)
        throw new Error("The parameter '_sort' cannot be null.");
    else if (_sort !== undefined)
        url_ += "_sort=" + encodeURIComponent("" + _sort) + "&";
    if (_start === null)
        throw new Error("The parameter '_start' cannot be null.");
    else if (_start !== undefined)
        url_ += "_start=" + encodeURIComponent("" + _start) + "&";
    if (eq === null)
        throw new Error("The parameter 'eq' cannot be null.");
    else if (eq !== undefined)
        url_ += "eq=" + encodeURIComponent("" + eq) + "&";
    if (_ne === null)
        throw new Error("The parameter '_ne' cannot be null.");
    else if (_ne !== undefined)
        url_ += "_ne=" + encodeURIComponent("" + _ne) + "&";
    if (_lt === null)
        throw new Error("The parameter '_lt' cannot be null.");
    else if (_lt !== undefined)
        url_ += "_lt=" + encodeURIComponent("" + _lt) + "&";
    if (_lte === null)
        throw new Error("The parameter '_lte' cannot be null.");
    else if (_lte !== undefined)
        url_ += "_lte=" + encodeURIComponent("" + _lte) + "&";
    if (_gt === null)
        throw new Error("The parameter '_gt' cannot be null.");
    else if (_gt !== undefined)
        url_ += "_gt=" + encodeURIComponent("" + _gt) + "&";
    if (_gte === null)
        throw new Error("The parameter '_gte' cannot be null.");
    else if (_gte !== undefined)
        url_ += "_gte=" + encodeURIComponent("" + _gte) + "&";
    if (_contains === null)
        throw new Error("The parameter '_contains' cannot be null.");
    else if (_contains !== undefined)
        url_ += "_contains=" + encodeURIComponent("" + _contains) + "&";
    if (_containss === null)
        throw new Error("The parameter '_containss' cannot be null.");
    else if (_containss !== undefined)
        url_ += "_containss=" + encodeURIComponent("" + _containss) + "&";
    if (_in === null)
        throw new Error("The parameter '_in' cannot be null.");
    else if (_in !== undefined)
        _in && _in.forEach(item => { url_ += "_in=" + encodeURIComponent("" + item) + "&"; });
    if (_nin === null)
        throw new Error("The parameter '_nin' cannot be null.");
    else if (_nin !== undefined)
        _nin && _nin.forEach(item => { url_ += "_nin=" + encodeURIComponent("" + item) + "&"; });
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static searchAllDefaultOptions?: UseQueryOptions<UsersPermissionsUser[], unknown, UsersPermissionsUser[]> = {};
    public static searchAllQueryKey(dto: SearchAllQueryParameters): QueryKey;
    public static searchAllQueryKey(id: string,_limit: number | undefined,_sort: string | undefined,_start: number | undefined,eq: string | undefined,_ne: string | undefined,_lt: string | undefined,_lte: string | undefined,_gt: string | undefined,_gte: string | undefined,_contains: string | undefined,_containss: string | undefined,_in: string[] | undefined,_nin: string[] | undefined): QueryKey;
    public static searchAllQueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { id, _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  } = params[0] as SearchAllQueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'searchAll',
                id as any,
                _limit as any,
                _sort as any,
                _start as any,
                eq as any,
                _ne as any,
                _lt as any,
                _lte as any,
                _gt as any,
                _gte as any,
                _contains as any,
                _containss as any,
                _in as any,
                _nin as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'searchAll',
                ...params
            ]);
        }
        
    }

    private static searchAll(context: QueryFunctionContext) {
        return Query.Client.searchAll(
                context.queryKey[2] as string, 
                context.queryKey[3] as number | undefined, 
                context.queryKey[4] as string | undefined, 
                context.queryKey[5] as number | undefined, 
                context.queryKey[6] as string | undefined, 
                context.queryKey[7] as string | undefined, 
                context.queryKey[8] as string | undefined, 
                context.queryKey[9] as string | undefined, 
                context.queryKey[10] as string | undefined, 
                context.queryKey[11] as string | undefined, 
                context.queryKey[12] as string | undefined, 
                context.queryKey[13] as string | undefined, 
                context.queryKey[14] as string[] | undefined, 
                context.queryKey[15] as string[] | undefined
            );
    }

    static useSearchAllQuery<TSelectData = UsersPermissionsUser[], TError = unknown>(dto: SearchAllQueryParameters, options?: UseQueryOptions<UsersPermissionsUser[], TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static useSearchAllQuery<TSelectData = UsersPermissionsUser[], TError = unknown>(id: string, _limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined, options?: UseQueryOptions<UsersPermissionsUser[], TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useSearchAllQuery<TSelectData = UsersPermissionsUser[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<UsersPermissionsUser[], TError, TSelectData> | undefined = undefined;
        let id: any = undefined;
        let _limit: any = undefined;
        let _sort: any = undefined;
        let _start: any = undefined;
        let eq: any = undefined;
        let _ne: any = undefined;
        let _lt: any = undefined;
        let _lte: any = undefined;
        let _gt: any = undefined;
        let _gte: any = undefined;
        let _contains: any = undefined;
        let _containss: any = undefined;
        let _in: any = undefined;
        let _nin: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ id, _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  } = params[0] as SearchAllQueryParameters);
                options = params[1];
            } else {
                [id, _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  options] = params;
            }
        }
    

        return useQuery<UsersPermissionsUser[], TError, TSelectData>({
            queryFn: Query.searchAll,
            queryKey: Query.searchAllQueryKey(id, _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin),
            ...Query.searchAllDefaultOptions as unknown as UseQueryOptions<UsersPermissionsUser[], TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static setSearchAllData(queryClient: QueryClient, updater: (data: UsersPermissionsUser[] | undefined) => UsersPermissionsUser[], id: string, _limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined) {
        queryClient.setQueryData(Query.searchAllQueryKey(id, _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin),
            updater
        );
    }

    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static setSearchAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: UsersPermissionsUser[] | undefined) => UsersPermissionsUser[]) {
        queryClient.setQueryData(queryKey, updater);
    }
    

    *(): string {
      let url_ = this.baseUrl + "/connect/*";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static *DefaultOptions?: UseQueryOptions<Anonymous16, unknown, Anonymous16> = {};
    public static *QueryKey(): QueryKey;
    public static *QueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'Client',
            '*',
            ]);
        
    }

    private static *() {
        return Query.Client.*(
            );
    }

    /**
     * @return response
     */
    static use*Query<TSelectData = Anonymous16, TError = unknown>(options?: UseQueryOptions<Anonymous16, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static use*Query<TSelectData = Anonymous16, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous16, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        return useQuery<Anonymous16, TError, TSelectData>({
            queryFn: Query.*,
            queryKey: Query.*QueryKey(),
            ...Query.*DefaultOptions as unknown as UseQueryOptions<Anonymous16, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static set*Data(queryClient: QueryClient, updater: (data: Anonymous16 | undefined) => Anonymous16, ) {
        queryClient.setQueryData(Query.*QueryKey(),
            updater
        );
    }

    /**
     * @return response
     */
    static set*DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous16 | undefined) => Anonymous16) {
        queryClient.setQueryData(queryKey, updater);
    }
        

    callback(provider: string): string {
      let url_ = this.baseUrl + "/auth/{provider}/callback";
    if (provider === undefined || provider === null)
        throw new Error("The parameter 'provider' must be defined.");
    url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static callbackDefaultOptions?: UseQueryOptions<Anonymous18, unknown, Anonymous18> = {};
    public static callbackQueryKey(provider: string): QueryKey;
    public static callbackQueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { provider,  } = params[0] as CallbackQueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'callback',
                provider as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'callback',
                ...params
            ]);
        }
        
    }

    private static callback(context: QueryFunctionContext) {
        return Query.Client.callback(
                context.queryKey[2] as string
            );
    }

    static useCallbackQuery<TSelectData = Anonymous18, TError = unknown>(dto: CallbackQueryParameters, options?: UseQueryOptions<Anonymous18, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @return response
     */
    static useCallbackQuery<TSelectData = Anonymous18, TError = unknown>(provider: string, options?: UseQueryOptions<Anonymous18, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useCallbackQuery<TSelectData = Anonymous18, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous18, TError, TSelectData> | undefined = undefined;
        let provider: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ provider,  } = params[0] as CallbackQueryParameters);
                options = params[1];
            } else {
                [provider,  options] = params;
            }
        }
    

        return useQuery<Anonymous18, TError, TSelectData>({
            queryFn: Query.callback,
            queryKey: Query.callbackQueryKey(provider),
            ...Query.callbackDefaultOptions as unknown as UseQueryOptions<Anonymous18, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setCallbackData(queryClient: QueryClient, updater: (data: Anonymous18 | undefined) => Anonymous18, provider: string) {
        queryClient.setQueryData(Query.callbackQueryKey(provider),
            updater
        );
    }

    /**
     * @return response
     */
    static setCallbackDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous18 | undefined) => Anonymous18) {
        queryClient.setQueryData(queryKey, updater);
    }
        

    emailConfirmation(): string {
      let url_ = this.baseUrl + "/auth/email-confirmation";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static emailConfirmationDefaultOptions?: UseQueryOptions<Anonymous21, unknown, Anonymous21> = {};
    public static emailConfirmationQueryKey(): QueryKey;
    public static emailConfirmationQueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'Client',
            'emailConfirmation',
            ]);
        
    }

    private static emailConfirmation() {
        return Query.Client.emailConfirmation(
            );
    }

    /**
     * @return response
     */
    static useEmailConfirmationQuery<TSelectData = Anonymous21, TError = unknown>(options?: UseQueryOptions<Anonymous21, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useEmailConfirmationQuery<TSelectData = Anonymous21, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<Anonymous21, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        return useQuery<Anonymous21, TError, TSelectData>({
            queryFn: Query.emailConfirmation,
            queryKey: Query.emailConfirmationQueryKey(),
            ...Query.emailConfirmationDefaultOptions as unknown as UseQueryOptions<Anonymous21, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setEmailConfirmationData(queryClient: QueryClient, updater: (data: Anonymous21 | undefined) => Anonymous21, ) {
        queryClient.setQueryData(Query.emailConfirmationQueryKey(),
            updater
        );
    }

    /**
     * @return response
     */
    static setEmailConfirmationDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Anonymous21 | undefined) => Anonymous21) {
        queryClient.setQueryData(queryKey, updater);
    }
      

    usersAll(_limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined): string {
      let url_ = this.baseUrl + "/users?";
    if (_limit === null)
        throw new Error("The parameter '_limit' cannot be null.");
    else if (_limit !== undefined)
        url_ += "_limit=" + encodeURIComponent("" + _limit) + "&";
    if (_sort === null)
        throw new Error("The parameter '_sort' cannot be null.");
    else if (_sort !== undefined)
        url_ += "_sort=" + encodeURIComponent("" + _sort) + "&";
    if (_start === null)
        throw new Error("The parameter '_start' cannot be null.");
    else if (_start !== undefined)
        url_ += "_start=" + encodeURIComponent("" + _start) + "&";
    if (eq === null)
        throw new Error("The parameter 'eq' cannot be null.");
    else if (eq !== undefined)
        url_ += "eq=" + encodeURIComponent("" + eq) + "&";
    if (_ne === null)
        throw new Error("The parameter '_ne' cannot be null.");
    else if (_ne !== undefined)
        url_ += "_ne=" + encodeURIComponent("" + _ne) + "&";
    if (_lt === null)
        throw new Error("The parameter '_lt' cannot be null.");
    else if (_lt !== undefined)
        url_ += "_lt=" + encodeURIComponent("" + _lt) + "&";
    if (_lte === null)
        throw new Error("The parameter '_lte' cannot be null.");
    else if (_lte !== undefined)
        url_ += "_lte=" + encodeURIComponent("" + _lte) + "&";
    if (_gt === null)
        throw new Error("The parameter '_gt' cannot be null.");
    else if (_gt !== undefined)
        url_ += "_gt=" + encodeURIComponent("" + _gt) + "&";
    if (_gte === null)
        throw new Error("The parameter '_gte' cannot be null.");
    else if (_gte !== undefined)
        url_ += "_gte=" + encodeURIComponent("" + _gte) + "&";
    if (_contains === null)
        throw new Error("The parameter '_contains' cannot be null.");
    else if (_contains !== undefined)
        url_ += "_contains=" + encodeURIComponent("" + _contains) + "&";
    if (_containss === null)
        throw new Error("The parameter '_containss' cannot be null.");
    else if (_containss !== undefined)
        url_ += "_containss=" + encodeURIComponent("" + _containss) + "&";
    if (_in === null)
        throw new Error("The parameter '_in' cannot be null.");
    else if (_in !== undefined)
        _in && _in.forEach(item => { url_ += "_in=" + encodeURIComponent("" + item) + "&"; });
    if (_nin === null)
        throw new Error("The parameter '_nin' cannot be null.");
    else if (_nin !== undefined)
        _nin && _nin.forEach(item => { url_ += "_nin=" + encodeURIComponent("" + item) + "&"; });
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static usersAllDefaultOptions?: UseQueryOptions<UsersPermissionsUser[], unknown, UsersPermissionsUser[]> = {};
    public static usersAllQueryKey(dto: UsersAllQueryParameters): QueryKey;
    public static usersAllQueryKey(_limit: number | undefined,_sort: string | undefined,_start: number | undefined,eq: string | undefined,_ne: string | undefined,_lt: string | undefined,_lte: string | undefined,_gt: string | undefined,_gte: string | undefined,_contains: string | undefined,_containss: string | undefined,_in: string[] | undefined,_nin: string[] | undefined): QueryKey;
    public static usersAllQueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  } = params[0] as UsersAllQueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'usersAll',
                _limit as any,
                _sort as any,
                _start as any,
                eq as any,
                _ne as any,
                _lt as any,
                _lte as any,
                _gt as any,
                _gte as any,
                _contains as any,
                _containss as any,
                _in as any,
                _nin as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'usersAll',
                ...params
            ]);
        }
        
    }

    private static usersAll(context: QueryFunctionContext) {
        return Query.Client.usersAll(
                context.queryKey[2] as number | undefined, 
                context.queryKey[3] as string | undefined, 
                context.queryKey[4] as number | undefined, 
                context.queryKey[5] as string | undefined, 
                context.queryKey[6] as string | undefined, 
                context.queryKey[7] as string | undefined, 
                context.queryKey[8] as string | undefined, 
                context.queryKey[9] as string | undefined, 
                context.queryKey[10] as string | undefined, 
                context.queryKey[11] as string | undefined, 
                context.queryKey[12] as string | undefined, 
                context.queryKey[13] as string[] | undefined, 
                context.queryKey[14] as string[] | undefined
            );
    }

    static useUsersAllQuery<TSelectData = UsersPermissionsUser[], TError = unknown>(dto: UsersAllQueryParameters, options?: UseQueryOptions<UsersPermissionsUser[], TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static useUsersAllQuery<TSelectData = UsersPermissionsUser[], TError = unknown>(_limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined, options?: UseQueryOptions<UsersPermissionsUser[], TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useUsersAllQuery<TSelectData = UsersPermissionsUser[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<UsersPermissionsUser[], TError, TSelectData> | undefined = undefined;
        let _limit: any = undefined;
        let _sort: any = undefined;
        let _start: any = undefined;
        let eq: any = undefined;
        let _ne: any = undefined;
        let _lt: any = undefined;
        let _lte: any = undefined;
        let _gt: any = undefined;
        let _gte: any = undefined;
        let _contains: any = undefined;
        let _containss: any = undefined;
        let _in: any = undefined;
        let _nin: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ _limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  } = params[0] as UsersAllQueryParameters);
                options = params[1];
            } else {
                [_limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin,  options] = params;
            }
        }
    

        return useQuery<UsersPermissionsUser[], TError, TSelectData>({
            queryFn: Query.usersAll,
            queryKey: Query.usersAllQueryKey(_limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin),
            ...Query.usersAllDefaultOptions as unknown as UseQueryOptions<UsersPermissionsUser[], TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static setUsersAllData(queryClient: QueryClient, updater: (data: UsersPermissionsUser[] | undefined) => UsersPermissionsUser[], _limit: number | undefined, _sort: string | undefined, _start: number | undefined, eq: string | undefined, _ne: string | undefined, _lt: string | undefined, _lte: string | undefined, _gt: string | undefined, _gte: string | undefined, _contains: string | undefined, _containss: string | undefined, _in: string[] | undefined, _nin: string[] | undefined) {
        queryClient.setQueryData(Query.usersAllQueryKey(_limit, _sort, _start, eq, _ne, _lt, _lte, _gt, _gte, _contains, _containss, _in, _nin),
            updater
        );
    }

    /**
     * @param _limit (optional) Maximum number of results possible
     * @param _sort (optional) Sort according to a specific field.
     * @param _start (optional) Skip a specific number of entries (especially useful for pagination)
     * @param eq (optional) Get entries that matches exactly your input
     * @param _ne (optional) Get records that are not equals to something
     * @param _lt (optional) Get record that are lower than a value
     * @param _lte (optional) Get records that are lower than or equal to a value
     * @param _gt (optional) Get records that are greater than a value
     * @param _gte (optional) Get records that are greater than  or equal a value
     * @param _contains (optional) Get records that contains a value
     * @param _containss (optional) Get records that contains (case sensitive) a value
     * @param _in (optional) Get records that matches any value in the array of values
     * @param _nin (optional) Get records that doesn't match any value in the array of values
     * @return response
     */
    static setUsersAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: UsersPermissionsUser[] | undefined) => UsersPermissionsUser[]) {
        queryClient.setQueryData(queryKey, updater);
    }
    

    me(): string {
      let url_ = this.baseUrl + "/users/me";
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static meDefaultOptions?: UseQueryOptions<UsersPermissionsUser, unknown, UsersPermissionsUser> = {};
    public static meQueryKey(): QueryKey;
    public static meQueryKey(...params: any[]): QueryKey {
        return removeUndefinedFromArrayTail([
            'Client',
            'me',
            ]);
        
    }

    private static me() {
        return Query.Client.me(
            );
    }

    /**
     * @return response
     */
    static useMeQuery<TSelectData = UsersPermissionsUser, TError = unknown>(options?: UseQueryOptions<UsersPermissionsUser, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useMeQuery<TSelectData = UsersPermissionsUser, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<UsersPermissionsUser, TError, TSelectData> | undefined = undefined;
        

        options = params[0] as any;
    

        return useQuery<UsersPermissionsUser, TError, TSelectData>({
            queryFn: Query.me,
            queryKey: Query.meQueryKey(),
            ...Query.meDefaultOptions as unknown as UseQueryOptions<UsersPermissionsUser, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setMeData(queryClient: QueryClient, updater: (data: UsersPermissionsUser | undefined) => UsersPermissionsUser, ) {
        queryClient.setQueryData(Query.meQueryKey(),
            updater
        );
    }

    /**
     * @return response
     */
    static setMeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: UsersPermissionsUser | undefined) => UsersPermissionsUser) {
        queryClient.setQueryData(queryKey, updater);
    }
    

    usersGET(id: string): string {
      let url_ = this.baseUrl + "/users/{id}";
    if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");
      return url_;
    }

    static usersGETDefaultOptions?: UseQueryOptions<UsersPermissionsUser, unknown, UsersPermissionsUser> = {};
    public static usersGETQueryKey(id: string): QueryKey;
    public static usersGETQueryKey(...params: any[]): QueryKey {

        if (params.length === 1 && isParameterObject(params[0])) {
            const { id,  } = params[0] as UsersGETQueryParameters;

            return removeUndefinedFromArrayTail([
                'Client',
                'usersGET',
                id as any,
            ]);
        } else {
            return removeUndefinedFromArrayTail([
                'Client',
                'usersGET',
                ...params
            ]);
        }
        
    }

    private static usersGET(context: QueryFunctionContext) {
        return Query.Client.usersGET(
                context.queryKey[2] as string
            );
    }

    static useUsersGETQuery<TSelectData = UsersPermissionsUser, TError = unknown>(dto: UsersGETQueryParameters, options?: UseQueryOptions<UsersPermissionsUser, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    /**
     * @return response
     */
    static useUsersGETQuery<TSelectData = UsersPermissionsUser, TError = unknown>(id: string, options?: UseQueryOptions<UsersPermissionsUser, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
    static useUsersGETQuery<TSelectData = UsersPermissionsUser, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {

        let options: UseQueryOptions<UsersPermissionsUser, TError, TSelectData> | undefined = undefined;
        let id: any = undefined;
        
        if (params.length > 0) {
            if (isParameterObject(params[0])) {
                ({ id,  } = params[0] as UsersGETQueryParameters);
                options = params[1];
            } else {
                [id,  options] = params;
            }
        }
    

        return useQuery<UsersPermissionsUser, TError, TSelectData>({
            queryFn: Query.usersGET,
            queryKey: Query.usersGETQueryKey(id),
            ...Query.usersGETDefaultOptions as unknown as UseQueryOptions<UsersPermissionsUser, TError, TSelectData>,
            ...options,
        });
    }
    /**
     * @return response
     */
    static setUsersGETData(queryClient: QueryClient, updater: (data: UsersPermissionsUser | undefined) => UsersPermissionsUser, id: string) {
        queryClient.setQueryData(Query.usersGETQueryKey(id),
            updater
        );
    }

    /**
     * @return response
     */
    static setUsersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: UsersPermissionsUser | undefined) => UsersPermissionsUser) {
        queryClient.setQueryData(queryKey, updater);
    }
        }

export class BuildingSite implements IBuildingSite {
    id!: string;
    address!: string;
    city!: string;
    district!: string;
    description!: string;
    status!: BuildingSiteStatus;
    published_at?: Date;

    constructor(data?: IBuildingSite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.status = BuildingSiteStatus.Ativo;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.district = _data["district"];
            this.description = _data["description"];
            this.status = _data["status"] !== undefined ? _data["status"] : BuildingSiteStatus.Ativo;
            this.published_at = _data["published_at"] ? new Date(_data["published_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BuildingSite {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingSite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address;
        data["city"] = this.city;
        data["district"] = this.district;
        data["description"] = this.description;
        data["status"] = this.status;
        data["published_at"] = this.published_at ? this.published_at.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBuildingSite {
    id: string;
    address: string;
    city: string;
    district: string;
    description: string;
    status: BuildingSiteStatus;
    published_at?: Date;
}

export class NewBuildingSite implements INewBuildingSite {
    address!: string;
    city!: string;
    district!: string;
    description!: string;
    status!: NewBuildingSiteStatus;
    published_at?: Date;
    created_by?: string;
    updated_by?: string;

    constructor(data?: INewBuildingSite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.status = NewBuildingSiteStatus.Ativo;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.city = _data["city"];
            this.district = _data["district"];
            this.description = _data["description"];
            this.status = _data["status"] !== undefined ? _data["status"] : NewBuildingSiteStatus.Ativo;
            this.published_at = _data["published_at"] ? new Date(_data["published_at"].toString()) : <any>undefined;
            this.created_by = _data["created_by"];
            this.updated_by = _data["updated_by"];
        }
    }

    static fromJS(data: any): NewBuildingSite {
        data = typeof data === 'object' ? data : {};
        let result = new NewBuildingSite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["city"] = this.city;
        data["district"] = this.district;
        data["description"] = this.description;
        data["status"] = this.status;
        data["published_at"] = this.published_at ? this.published_at.toISOString() : <any>undefined;
        data["created_by"] = this.created_by;
        data["updated_by"] = this.updated_by;
        return data;
    }
}

export interface INewBuildingSite {
    address: string;
    city: string;
    district: string;
    description: string;
    status: NewBuildingSiteStatus;
    published_at?: Date;
    created_by?: string;
    updated_by?: string;
}

export class UsersPermissionsRole implements IUsersPermissionsRole {
    id!: string;
    name!: string;
    description?: string;
    type?: string;
    permissions?: Permissions[];
    users?: Users[];

    constructor(data?: IUsersPermissionsRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
        }
    }

    static fromJS(data: any): UsersPermissionsRole {
        data = typeof data === 'object' ? data : {};
        let result = new UsersPermissionsRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        return data;
    }
}

export interface IUsersPermissionsRole {
    id: string;
    name: string;
    description?: string;
    type?: string;
    permissions?: Permissions[];
    users?: Users[];
}

export class NewUsersPermissionsRole implements INewUsersPermissionsRole {
    name!: string;
    description?: string;
    type?: string;
    permissions?: string[];
    users?: string[];
    created_by?: string;
    updated_by?: string;

    constructor(data?: INewUsersPermissionsRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            this.created_by = _data["created_by"];
            this.updated_by = _data["updated_by"];
        }
    }

    static fromJS(data: any): NewUsersPermissionsRole {
        data = typeof data === 'object' ? data : {};
        let result = new NewUsersPermissionsRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        data["created_by"] = this.created_by;
        data["updated_by"] = this.updated_by;
        return data;
    }
}

export interface INewUsersPermissionsRole {
    name: string;
    description?: string;
    type?: string;
    permissions?: string[];
    users?: string[];
    created_by?: string;
    updated_by?: string;
}

export class UsersPermissionsUser implements IUsersPermissionsUser {
    id!: string;
    username!: string;
    email!: string;
    provider?: string;
    confirmed?: boolean;
    blocked?: boolean;
    role?: Role;

    constructor(data?: IUsersPermissionsUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.confirmed = false;
            this.blocked = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.provider = _data["provider"];
            this.confirmed = _data["confirmed"] !== undefined ? _data["confirmed"] : false;
            this.blocked = _data["blocked"] !== undefined ? _data["blocked"] : false;
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UsersPermissionsUser {
        data = typeof data === 'object' ? data : {};
        let result = new UsersPermissionsUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["email"] = this.email;
        data["provider"] = this.provider;
        data["confirmed"] = this.confirmed;
        data["blocked"] = this.blocked;
        data["role"] = this.role;
        return data;
    }
}

export interface IUsersPermissionsUser {
    id: string;
    username: string;
    email: string;
    provider?: string;
    confirmed?: boolean;
    blocked?: boolean;
    role?: Role;
}

export class NewUsersPermissionsUser implements INewUsersPermissionsUser {
    username!: string;
    email!: string;
    provider?: string;
    password?: string;
    resetPasswordToken?: string;
    confirmationToken?: string;
    confirmed?: boolean;
    blocked?: boolean;
    role?: string;
    created_by?: string;
    updated_by?: string;

    constructor(data?: INewUsersPermissionsUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.confirmed = false;
            this.blocked = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.email = _data["email"];
            this.provider = _data["provider"];
            this.password = _data["password"];
            this.resetPasswordToken = _data["resetPasswordToken"];
            this.confirmationToken = _data["confirmationToken"];
            this.confirmed = _data["confirmed"] !== undefined ? _data["confirmed"] : false;
            this.blocked = _data["blocked"] !== undefined ? _data["blocked"] : false;
            this.role = _data["role"];
            this.created_by = _data["created_by"];
            this.updated_by = _data["updated_by"];
        }
    }

    static fromJS(data: any): NewUsersPermissionsUser {
        data = typeof data === 'object' ? data : {};
        let result = new NewUsersPermissionsUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["email"] = this.email;
        data["provider"] = this.provider;
        data["password"] = this.password;
        data["resetPasswordToken"] = this.resetPasswordToken;
        data["confirmationToken"] = this.confirmationToken;
        data["confirmed"] = this.confirmed;
        data["blocked"] = this.blocked;
        data["role"] = this.role;
        data["created_by"] = this.created_by;
        data["updated_by"] = this.updated_by;
        return data;
    }
}

export interface INewUsersPermissionsUser {
    username: string;
    email: string;
    provider?: string;
    password?: string;
    resetPasswordToken?: string;
    confirmationToken?: string;
    confirmed?: boolean;
    blocked?: boolean;
    role?: string;
    created_by?: string;
    updated_by?: string;
}

export class ErrorDto implements IErrorDto {
    code!: number;
    message!: string;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data;
    }
}

export interface IErrorDto {
    code: number;
    message: string;
}

export class Body implements IBody {
    foo?: string;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IBody {
    foo?: string;
}

export class Body2 implements IBody2 {
    foo?: string;

    constructor(data?: IBody2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Body2 {
        data = typeof data === 'object' ? data : {};
        let result = new Body2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IBody2 {
    foo?: string;
}

export class Body3 implements IBody3 {
    foo?: string;

    constructor(data?: IBody3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Body3 {
        data = typeof data === 'object' ? data : {};
        let result = new Body3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IBody3 {
    foo?: string;
}

export class Body4 implements IBody4 {
    foo?: string;

    constructor(data?: IBody4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Body4 {
        data = typeof data === 'object' ? data : {};
        let result = new Body4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IBody4 {
    foo?: string;
}

export class Body5 implements IBody5 {
    foo?: string;

    constructor(data?: IBody5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Body5 {
        data = typeof data === 'object' ? data : {};
        let result = new Body5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IBody5 {
    foo?: string;
}

export class Body6 implements IBody6 {
    foo?: string;

    constructor(data?: IBody6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Body6 {
        data = typeof data === 'object' ? data : {};
        let result = new Body6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IBody6 {
    foo?: string;
}

export class Body7 implements IBody7 {
    foo?: string;

    constructor(data?: IBody7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Body7 {
        data = typeof data === 'object' ? data : {};
        let result = new Body7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IBody7 {
    foo?: string;
}

export class Anonymous implements IAnonymous {
    foo?: string;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous {
    foo?: string;
}

export class Anonymous2 implements IAnonymous2 {
    foo?: string;

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous2 {
    foo?: string;
}

export class Anonymous3 implements IAnonymous3 {
    foo?: string;

    constructor(data?: IAnonymous3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous3 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous3 {
    foo?: string;
}

export class Anonymous4 implements IAnonymous4 {
    foo?: string;

    constructor(data?: IAnonymous4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous4 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous4 {
    foo?: string;
}

export class Anonymous5 implements IAnonymous5 {
    foo?: string;

    constructor(data?: IAnonymous5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous5 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous5 {
    foo?: string;
}

export class Anonymous6 implements IAnonymous6 {
    foo?: string;

    constructor(data?: IAnonymous6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous6 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous6 {
    foo?: string;
}

export class Anonymous7 implements IAnonymous7 {
    foo?: string;

    constructor(data?: IAnonymous7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous7 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous7 {
    foo?: string;
}

export class Anonymous8 implements IAnonymous8 {
    foo?: string;

    constructor(data?: IAnonymous8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous8 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous8 {
    foo?: string;
}

export class Anonymous9 implements IAnonymous9 {
    foo?: string;

    constructor(data?: IAnonymous9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous9 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous9 {
    foo?: string;
}

export class Anonymous10 implements IAnonymous10 {
    foo?: string;

    constructor(data?: IAnonymous10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous10 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous10 {
    foo?: string;
}

export class Anonymous11 implements IAnonymous11 {
    foo?: string;

    constructor(data?: IAnonymous11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous11 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous11 {
    foo?: string;
}

export class Anonymous12 implements IAnonymous12 {
    foo?: string;

    constructor(data?: IAnonymous12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous12 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous12 {
    foo?: string;
}

export class Anonymous13 implements IAnonymous13 {
    foo?: string;

    constructor(data?: IAnonymous13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous13 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous13 {
    foo?: string;
}

export class Anonymous14 implements IAnonymous14 {
    foo?: string;

    constructor(data?: IAnonymous14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous14 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous14 {
    foo?: string;
}

export class Anonymous15 implements IAnonymous15 {
    foo?: string;

    constructor(data?: IAnonymous15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous15 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous15 {
    foo?: string;
}

export class Anonymous16 implements IAnonymous16 {
    foo?: string;

    constructor(data?: IAnonymous16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous16 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous16 {
    foo?: string;
}

export class Anonymous17 implements IAnonymous17 {
    foo?: string;

    constructor(data?: IAnonymous17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous17 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous17 {
    foo?: string;
}

export class Anonymous18 implements IAnonymous18 {
    foo?: string;

    constructor(data?: IAnonymous18) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous18 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous18();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous18 {
    foo?: string;
}

export class Anonymous19 implements IAnonymous19 {
    foo?: string;

    constructor(data?: IAnonymous19) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous19 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous19();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous19 {
    foo?: string;
}

export class Anonymous20 implements IAnonymous20 {
    foo?: string;

    constructor(data?: IAnonymous20) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous20 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous20();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous20 {
    foo?: string;
}

export class Anonymous21 implements IAnonymous21 {
    foo?: string;

    constructor(data?: IAnonymous21) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous21 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous21();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous21 {
    foo?: string;
}

export class Anonymous22 implements IAnonymous22 {
    foo?: string;

    constructor(data?: IAnonymous22) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous22 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous22();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous22 {
    foo?: string;
}

export class Anonymous23 implements IAnonymous23 {
    foo?: string;

    constructor(data?: IAnonymous23) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foo = _data["foo"];
        }
    }

    static fromJS(data: any): Anonymous23 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous23();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foo"] = this.foo;
        return data;
    }
}

export interface IAnonymous23 {
    foo?: string;
}

export enum BuildingSiteStatus {
    Ativo = "ativo",
    Inativo = "inativo",
}

export enum NewBuildingSiteStatus {
    Ativo = "ativo",
    Inativo = "inativo",
}

export class Permissions implements IPermissions {
    id!: string;
    type!: string;
    controller!: string;
    action!: string;
    enabled!: boolean;
    policy?: string;
    role?: string;
    created_by?: string;
    updated_by?: string;

    constructor(data?: IPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.controller = _data["controller"];
            this.action = _data["action"];
            this.enabled = _data["enabled"];
            this.policy = _data["policy"];
            this.role = _data["role"];
            this.created_by = _data["created_by"];
            this.updated_by = _data["updated_by"];
        }
    }

    static fromJS(data: any): Permissions {
        data = typeof data === 'object' ? data : {};
        let result = new Permissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["controller"] = this.controller;
        data["action"] = this.action;
        data["enabled"] = this.enabled;
        data["policy"] = this.policy;
        data["role"] = this.role;
        data["created_by"] = this.created_by;
        data["updated_by"] = this.updated_by;
        return data;
    }
}

export interface IPermissions {
    id: string;
    type: string;
    controller: string;
    action: string;
    enabled: boolean;
    policy?: string;
    role?: string;
    created_by?: string;
    updated_by?: string;
}

export class Users implements IUsers {
    id!: string;
    username!: string;
    email!: string;
    provider?: string;
    password?: string;
    resetPasswordToken?: string;
    confirmationToken?: string;
    confirmed?: boolean;
    blocked?: boolean;
    role?: string;
    created_by?: string;
    updated_by?: string;

    constructor(data?: IUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.provider = _data["provider"];
            this.password = _data["password"];
            this.resetPasswordToken = _data["resetPasswordToken"];
            this.confirmationToken = _data["confirmationToken"];
            this.confirmed = _data["confirmed"];
            this.blocked = _data["blocked"];
            this.role = _data["role"];
            this.created_by = _data["created_by"];
            this.updated_by = _data["updated_by"];
        }
    }

    static fromJS(data: any): Users {
        data = typeof data === 'object' ? data : {};
        let result = new Users();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["email"] = this.email;
        data["provider"] = this.provider;
        data["password"] = this.password;
        data["resetPasswordToken"] = this.resetPasswordToken;
        data["confirmationToken"] = this.confirmationToken;
        data["confirmed"] = this.confirmed;
        data["blocked"] = this.blocked;
        data["role"] = this.role;
        data["created_by"] = this.created_by;
        data["updated_by"] = this.updated_by;
        return data;
    }
}

export interface IUsers {
    id: string;
    username: string;
    email: string;
    provider?: string;
    password?: string;
    resetPasswordToken?: string;
    confirmationToken?: string;
    confirmed?: boolean;
    blocked?: boolean;
    role?: string;
    created_by?: string;
    updated_by?: string;
}

export class Role implements IRole {
    id!: string;
    name!: string;
    description?: string;
    type?: string;
    permissions?: string[];
    users?: string[];
    created_by?: string;
    updated_by?: string;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            this.created_by = _data["created_by"];
            this.updated_by = _data["updated_by"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        data["created_by"] = this.created_by;
        data["updated_by"] = this.updated_by;
        return data;
    }
}

export interface IRole {
    id: string;
    name: string;
    description?: string;
    type?: string;
    permissions?: string[];
    users?: string[];
    created_by?: string;
    updated_by?: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

import { useQuery, UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey } from 'react-query';

function removeUndefinedFromArrayTail<T>(arr: T[]): T[] {
    let lastDefinedValueIndex = arr.length - 1;
    while (lastDefinedValueIndex >= 0) {
        if (arr[lastDefinedValueIndex] === undefined) {
            lastDefinedValueIndex--;
        } else {
            break;
        }
    }
    return lastDefinedValueIndex === arr.length - 1 ? arr : arr.slice(0, lastDefinedValueIndex + 1);
}

/*
  Determines if first parameter of useSomethingQuery is an object with query parameters, or it's a regular parameter
  Returns true if parameter is Object
  Returns false if parameter is number/string/boolean/Date or Array
*/
function isParameterObject(param: unknown) {
    if (param === null || param === undefined) return false;
    if (param instanceof Array) return false;
    const isObject = typeof param === 'object';
    if (!isObject) return false;
    if (param instanceof Date) return false;
    return true;
}

type ClientFactoryFunction = <T>(type: (new (...params: any[]) => T)) => T;
let _clientFactoryFunction: ClientFactoryFunction = <T>(type: (new (...params: any[]) => T)) => {
  const params = [_baseUrl, _fetchFactory()];
  return new type(...params);
};
/*
  Overrides default Client factory function
*/
export function setClientFactory(value: ClientFactoryFunction) {
  _clientFactoryFunction = value;
}

/*
  Returns current Client factory function
*/
export function getClientFactory() {
  return _clientFactoryFunction;
}

/*
  Function that will be called from `useQuery...` methods to get a client of certain type
*/
function createClient<T>(type: (new () => T)) {
  return _clientFactoryFunction(type);
}

let _baseUrl = '';
/*
  Returns the base URL for http requests
*/
export function getBaseUrl(): string {
  return _baseUrl;
}

/*
  Sets the base URL for http requests
*/
export function setBaseUrl(baseUrl: string) {
  _baseUrl = baseUrl;
}

let _fetchFactory = () => <any>window;
/*
  Returns currently used factory for fetch
*/
export function getFetchFactory(): () => { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }  {
  return _fetchFactory;
}
/*
  Sets currently used factory for fetch
*/
export function setFetchFactory(factory: () => { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
  _fetchFactory = factory;
}